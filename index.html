<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>我的作品集</title>
<style>
  html, body {
    margin: 0; height: 100%;
    background: #0b0c0f;
    overflow-y: auto;
    cursor: none; /* 隐藏系统光标 */
  }
  #viewer {
    width: min(1200px, 96vw);
    margin: 0 auto;
    padding: 4vh 0 10vh;
    display: grid; gap: 24px;
  }
  .pageCanvas {
    width: 100%; height: auto; display: block;
    background: #111; border-radius: 8px;
    box-shadow: 0 20px 60px rgba(0,0,0,.35), 0 2px 12px rgba(0,0,0,.35);
  }

  /* 纯透镜：完全透明容器，无阴影、无描边、无滤镜 */
  #glassCursor{
    position: fixed; left: 0; top: 0;
    width: 65px; height: 65px; /* 透镜直径（CSS） */
    border-radius: 50%;
    pointer-events: none; z-index: 9999;
    transform: translate(-9999px,-9999px);
    background: transparent;
    mix-blend-mode: normal; /* 防止混色造成发灰 */
  }
  /* 只用画布内容，周围透明 */
  #magnifyCanvas{
    display: block;
    width: 110px; height: 110px;   /* 与上面保持一致 */
    border-radius: 50%;
    background: transparent;
  }

  ::-webkit-scrollbar { width: 10px; }
  ::-webkit-scrollbar-thumb { background: #2a2d33; border-radius: 6px; }
  ::-webkit-scrollbar-track { background: #0f1115; }
</style>
</head>
<body>
  <div id="viewer" aria-label="PDF Viewer"></div>

  <!-- 纯透明容器，放大图像只绘在圆形画布内 -->
  <div id="glassCursor" aria-hidden="true">
    <canvas id="magnifyCanvas"></canvas>
  </div>

  <!-- 本地 PDF.js -->
  <script src="./lib/pdfjs/pdf.min.js"></script>
  <script>
    // ===== 参数 =====
    const PDF_URL      = "portfolio.pdf";
    const BASE_SCALE   = 1.5;
    const MAGNIFY_ZOOM = 1.9;   // 放大倍率
    const MAG_SIZE_CSS = 110;   // 透镜直径（CSS）
    const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2)); // 兼顾清晰与性能

    // worker 指向本地，避免跨域/CSP
    pdfjsLib.GlobalWorkerOptions.workerSrc = "./lib/pdfjs/pdf.worker.min.js";

    const viewer    = document.getElementById("viewer");
    const cursorEl  = document.getElementById("glassCursor");
    const magCanvas = document.getElementById("magnifyCanvas");
    const magCtx    = magCanvas.getContext("2d", { alpha: true });

    // 设置放大镜画布的物理像素，保证清晰且完全透明
    function setupMagCanvas(){
      magCanvas.width  = Math.round(MAG_SIZE_CSS * dpr);
      magCanvas.height = Math.round(MAG_SIZE_CSS * dpr);
      magCanvas.style.width  = MAG_SIZE_CSS + "px";
      magCanvas.style.height = MAG_SIZE_CSS + "px";
    }
    setupMagCanvas();

    // ===== 渲染 PDF =====
    (async () => {
      try {
        const pdf = await pdfjsLib.getDocument(PDF_URL).promise;
        for (let p = 1; p <= pdf.numPages; p++) {
          const page = await pdf.getPage(p);
          const viewport1 = page.getViewport({ scale: 1 });
          const containerW = Math.min(1200, window.innerWidth * 0.96);
          const scale = Math.min(BASE_SCALE, containerW / viewport1.width);
          const viewport = page.getViewport({ scale });

          const canvas = document.createElement("canvas");
          canvas.className = "pageCanvas";
          canvas.width  = Math.ceil(viewport.width);
          canvas.height = Math.ceil(viewport.height);
          const ctx = canvas.getContext("2d", { alpha: false });

          await page.render({ canvasContext: ctx, viewport }).promise;
          viewer.appendChild(canvas);
        }
      } catch (e) {
        console.error(e);
        viewer.innerHTML = '<p style="color:#fff;text-align:center;opacity:.8;">加载失败：请确认 <b>portfolio.pdf</b> 在根目录。</p>';
      }
    })();

    // ===== 纯透镜放大（无任何额外叠加） =====
    const R_css = MAG_SIZE_CSS / 2;
    const R_px  = magCanvas.width / 2;

    let targetX = -9999, targetY = -9999, curX = -9999, curY = -9999;
    (function follow(){
      curX += (targetX - curX) * 0.22;
      curY += (targetY - curY) * 0.22;
      cursorEl.style.transform = `translate(${curX - R_css}px, ${curY - R_css}px)`;
      requestAnimationFrame(follow);
    })();

    document.addEventListener("mousemove", (ev) => {
      targetX = ev.clientX;
      targetY = ev.clientY;

      const el = document.elementsFromPoint(ev.clientX, ev.clientY)
                 .find(n => n.classList?.contains("pageCanvas"));
      // 清空整个画布，确保外圈完全透明
      magCtx.clearRect(0, 0, magCanvas.width, magCanvas.height);

      if (!el) return;

      const rect = el.getBoundingClientRect();
      const px = (ev.clientX - rect.left) * (el.width / rect.width);
      const py = (ev.clientY - rect.top)  * (el.height / rect.height);

      const srcSize = (MAG_SIZE_CSS / MAGNIFY_ZOOM);  // 源采样直径（CSS）
      const srcSizePx = srcSize; // el 是像素画布，已是像素单位
      const sx = Math.max(0, Math.min(el.width  - srcSizePx, px - srcSizePx/2));
      const sy = Math.max(0, Math.min(el.height - srcSizePx, py - srcSizePx/2));

      // 裁成完美圆形，只绘内容，不叠任何渐变/边框
      magCtx.save();
      magCtx.beginPath();
      magCtx.arc(R_px, R_px, R_px, 0, Math.PI * 2);
      magCtx.clip();

      magCtx.imageSmoothingEnabled = true;
      magCtx.imageSmoothingQuality = "high";
      magCtx.drawImage(el, sx, sy, srcSizePx, srcSizePx, 0, 0, magCanvas.width, magCanvas.height);
      magCtx.restore();
    }, { passive: true });

    // 触屏禁用自定义光标
    if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
      document.body.style.cursor = 'auto';
      cursorEl.style.display = 'none';
    }

    // 视口变化时，保持高分屏清晰
    window.addEventListener('resize', () => {
      setupMagCanvas();
    });
  </script>
</body>
</html>
