<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>我的作品集</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #0b0c0f;
    overflow-y: auto;
    cursor: none; /* 隐藏系统鼠标 */
  }
  #viewer {
    width: min(1200px, 96vw);
    margin: 0 auto;
    padding: 4vh 0 10vh;
    display: grid;
    gap: 24px;
  }
  .pageCanvas {
    width: 100%;
    height: auto;
    display: block;
    background: #111;
    border-radius: 8px;
    box-shadow: 0 20px 60px rgba(0,0,0,.35), 0 2px 12px rgba(0,0,0,.35);
  }

  /* —— 玻璃透镜光标（无描边、无磨砂） —— */
  #glassCursor{
    position: fixed;
    left: 0; top: 0;
    width: 110px; height: 110px;          /* 光标更小 */
    pointer-events: none; z-index: 9999; border-radius: 50%;
    transform: translate(-9999px,-9999px);
    background: transparent;              /* 透明，不叠任何底色 */
    box-shadow: 0 8px 24px rgba(0,0,0,0.35); /* 仅外投影，营造悬浮感 */
    /* 可选：极轻微的内辉光（几乎不可见，不算描边） */
    /* filter: drop-shadow(0 0 1px rgba(255,255,255,0.08)); */
  }
  #magnifyCanvas{
    width: 100%;
    height: 100%;
    display: block;
    border-radius: 50%;
  }

  ::-webkit-scrollbar { width: 10px; }
  ::-webkit-scrollbar-thumb { background: #2a2d33; border-radius: 6px; }
  ::-webkit-scrollbar-track { background: #0f1115; }
</style>
</head>
<body>
  <div id="viewer" aria-label="PDF Viewer"></div>

  <!-- 玻璃透镜光标（放大结果绘制在内部 canvas） -->
  <div id="glassCursor" aria-hidden="true">
    <!-- 将画布分辨率设为两倍，提高清晰度；CSS 大小由 #glassCursor 控制 -->
    <canvas id="magnifyCanvas" width="220" height="220"></canvas>
  </div>

  <!-- 使用“本地”PDF.js（请确保 /lib/pdfjs/ 下有这两个文件） -->
  <script src="./lib/pdfjs/pdf.min.js"></script>
  <script>
    // ========== 可调参数 ==========
    const PDF_URL      = "portfolio.pdf";  // PDF 文件名（与根目录一致）
    const BASE_SCALE   = 1.5;              // 页面渲染清晰度
    const MAGNIFY_ZOOM = 1.9;              // 放大倍率（1.6~2.2 之间按需调）
    const MAG_SIZE_CSS = 110;              // 透镜直径（CSS 尺寸，需与 #glassCursor 保持一致）
    const MAG_RADIUS   = MAG_SIZE_CSS / 2;

    // 指向本地 worker，避免跨域/CSP 问题
    pdfjsLib.GlobalWorkerOptions.workerSrc = "./lib/pdfjs/pdf.worker.min.js";

    const viewer   = document.getElementById("viewer");
    const cursorEl = document.getElementById("glassCursor");
    const magCanvas = document.getElementById("magnifyCanvas");
    const magCtx    = magCanvas.getContext("2d", { alpha: true });

    // ========== 渲染 PDF ==========
    (async () => {
      try {
        const pdf = await pdfjsLib.getDocument(PDF_URL).promise;
        for (let p = 1; p <= pdf.numPages; p++) {
          const page = await pdf.getPage(p);
          const viewport1 = page.getViewport({ scale: 1 });
          const containerW = Math.min(1200, window.innerWidth * 0.96);
          const scale = Math.min(BASE_SCALE, containerW / viewport1.width);
          const viewport = page.getViewport({ scale });

          const canvas = document.createElement("canvas");
          canvas.className = "pageCanvas";
          canvas.width  = Math.ceil(viewport.width);
          canvas.height = Math.ceil(viewport.height);

          const ctx = canvas.getContext("2d");
          await page.render({ canvasContext: ctx, viewport }).promise;
          viewer.appendChild(canvas);
        }
      } catch (e) {
        console.error(e);
        viewer.innerHTML = '<p style="color:#fff;text-align:center;opacity:.8;">加载失败：请确认 <b>portfolio.pdf</b> 位于仓库根目录（区分大小写）。</p>';
      }
    })();

    // ========== 玻璃透镜放大效果 ==========
    // 平滑跟随（减震）
    let targetX = -9999, targetY = -9999, curX = -9999, curY = -9999;
    (function follow(){
      curX += (targetX - curX) * 0.22;
      curY += (targetY - curY) * 0.22;
      cursorEl.style.transform = `translate(${curX - MAG_RADIUS}px, ${curY - MAG_RADIUS}px)`;
      requestAnimationFrame(follow);
    })();

    document.addEventListener("mousemove", (ev) => {
      targetX = ev.clientX;
      targetY = ev.clientY;

      // 找到指针下的 PDF 画布
      const el = document.elementsFromPoint(ev.clientX, ev.clientY)
                  .find(n => n.classList?.contains("pageCanvas"));
      if (!el) {
        // 不在PDF区域时清空透镜画面，但仍保留透明玻璃圈
        magCtx.clearRect(0, 0, magCanvas.width, magCanvas.height);
        return;
      }

      // 计算指针在该 canvas 内的像素坐标
      const rect = el.getBoundingClientRect();
      const px = (ev.clientX - rect.left) * (el.width / rect.width);
      const py = (ev.clientY - rect.top)  * (el.height / rect.height);

      // 采样区域大小（源图的直径）
      const srcSize = (MAG_SIZE_CSS / MAGNIFY_ZOOM);
      const sx = Math.max(0, Math.min(el.width  - srcSize, px - srcSize/2));
      const sy = Math.max(0, Math.min(el.height - srcSize, py - srcSize/2));

      // 清空并裁圆
      magCtx.clearRect(0, 0, magCanvas.width, magCanvas.height);
      magCtx.save();
      magCtx.beginPath();
      magCtx.arc(magCanvas.width/2, magCanvas.height/2, magCanvas.width/2 - 1, 0, Math.PI * 2);
      magCtx.closePath();
      magCtx.clip();

      // 绘制放大图像（高质量插值）
      magCtx.imageSmoothingEnabled = true;
      magCtx.imageSmoothingQuality = "high";
      magCtx.drawImage(el, sx, sy, srcSize, srcSize, 0, 0, magCanvas.width, magCanvas.height);
      magCtx.restore();
      // 不再叠加任何白边/渐变，保持纯“透镜”效果
    });

    // 触屏设备禁用自定义光标
    if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
      document.body.style.cursor = 'auto';
      cursorEl.style.display = 'none';
    }
  </script>
</body>
</html>
